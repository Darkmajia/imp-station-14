using System.Text; // imp
using Content.Shared.Traits;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes; // imp

namespace Content.Client.Lobby.UI.Roles;

[GenerateTypedNameReferences]
public sealed partial class TraitPreferenceSelector : Control
{
    private readonly IPrototypeManager _prototypeManager; // imp

    public int Cost;

    public bool Preference
    {
        get => Checkbox.Pressed;
        set => Checkbox.Pressed = value;
    }

    public event Action<bool>? PreferenceChanged;

    // imp edit - added prototypeManager
    public TraitPreferenceSelector(TraitPrototype trait, IPrototypeManager prototypeManager)
    {
        _prototypeManager = prototypeManager; // imp edit
        RobustXamlLoader.Load(this);

        var text = trait.Cost != 0 ? $"[{trait.Cost}] " : "";
        text += Loc.GetString(trait.Name);

        Cost = trait.Cost;
        Checkbox.Text = text;
        Checkbox.OnToggled += OnCheckBoxToggled;

        if (trait.Description is { } desc)
        {
            // imp edit - expanded description to list incompatible traits
            var fullDesc = new StringBuilder();
            fullDesc.AppendLine(Loc.GetString(desc));

            foreach (var incompatible in trait.IncompatibleWith)
            {
                var incompatibleProto = _prototypeManager.Index<TraitPrototype>(incompatible);
                var incompatibleName = Loc.GetString(incompatibleProto.Name);
                fullDesc.AppendLine(Loc.GetString("trait-incompatibility", ("trait", incompatibleName)));
            }

            Checkbox.ToolTip = fullDesc.ToString().Trim();
            // end imp edit
        }
    }

    private void OnCheckBoxToggled(BaseButton.ButtonToggledEventArgs args)
    {
        PreferenceChanged?.Invoke(Preference);
    }
}
